
    util seq(funcs, done) should return a function that runs asynchronous functions in funcs in order: [2K[0G  â€¤ util seq(funcs, done) should return a function that runs asynchronous functions in funcs in order
    util seq(funcs, done) should handle errors by calling done with the error: [2K[0G  â€¤ util seq(funcs, done) should handle errors by calling done with the error
    util seq(funcs, done) should handle exceptions thrown by functions by calling done with the exception: [2K[0G  â€¤ util seq(funcs, done) should handle exceptions thrown by functions by calling done with the exception
    util seq(funcs, done) should call done with no error if all is successful: [2K[0G  â€¤ util seq(funcs, done) should call done with no error if all is successful
    util seq(funcs, done) _.to(names...) should return a function that places the corresponding arguments in "this" (skipping err): [2K[0G  â€¤ util seq(funcs, done) _.to(names...) should return a function that places the corresponding arguments in "this" (skipping err)
    util timeUid() should return a unique string: [2K[0G  â€¤ util timeUid() should return a unique string
    util timeUid() should return a larger value when called over one millisecond later: [2K[0G  â€¤ util timeUid() should return a larger value when called over one millisecond later
    util Encoder(allowedSpecial) .encode(str) should encode str in a way that will only include letters, digits or characters from allowedSpecial: [2K[0G  â€¤ util Encoder(allowedSpecial) .encode(str) should encode str in a way that will only include letters, digits or characters from allowedSpecial
    util Encoder(allowedSpecial) .encode(str) should throw an exception if less than three special characters are allowed: [2K[0G  â€¤ util Encoder(allowedSpecial) .encode(str) should throw an exception if less than three special characters are allowed
    util Encoder(allowedSpecial) .decode(enc) should decode a string encoded with .encode(): [2K[0G  â€¤ util Encoder(allowedSpecial) .decode(enc) should decode a string encoded with .encode()
    util parallel(n, callback) should return a callback function that will call "callback" after it has been called n times: [2K[0G  â€¤ util parallel(n, callback) should return a callback function that will call "callback" after it has been called n times
    util parallel(n, callback) should call the callback immediately with an error if an error is given to the parallel callback: [2K[0G  â€¤ util parallel(n, callback) should call the callback immediately with an error if an error is given to the parallel callback
    util Worker should call a given function iteratively, in given intervals, until stopped: [2K[0G  â€¤ util Worker should call a given function iteratively, in given intervals, until stopped
    util Worker should assure that no more than a given number of instances of the function are running at any given time: [2K[0G  â€¤ util Worker should assure that no more than a given number of instances of the function are running at any given time
    MongoFS should retrieve the value with the highest _ts value: [2K[0G  â€¤ MongoFS should retrieve the value with the highest _ts value
    MongoFS should support any kind of characters in paths, with the exception that slash (/) and star (*): [2K[0G  â€¤ MongoFS should support any kind of characters in paths, with the exception that slash (/) and star (*)
    MongoFS .get(path, callback(err, file)) should retrieve the value of a file: [2K[0G  â€¤ MongoFS .get(path, callback(err, file)) should retrieve the value of a file
    MongoFS .get(path, callback(err, file)) should retrieve the last value in the array, regardless of the _ts value: [2K[0G  â€¤ MongoFS .get(path, callback(err, file)) should retrieve the last value in the array, regardless of the _ts value
    MongoFS .put(path, file, callback(err)) should write a file so that get() retrieves it: [2K[0G  â€¤ MongoFS .put(path, file, callback(err)) should write a file so that get() retrieves it
    MongoFS .put(path, file, callback(err)) should assign a timestamp to a file if one is not provided: [2K[0G  â€¤ MongoFS .put(path, file, callback(err)) should assign a timestamp to a file if one is not provided
    MongoFS .put(path, file, callback(err)) should reflect the provided timestamp if one is given: [2K[0G  â€¤ MongoFS .put(path, file, callback(err)) should reflect the provided timestamp if one is given
    MongoFS .batchPut(keyVals, callback(err)) should put files for all key/value pairs in the given object: [2K[0G  â€¤ MongoFS .batchPut(keyVals, callback(err)) should put files for all key/value pairs in the given object
    MongoFS .getDir(path, expandFiles, callback(err, content)) should retrieve the names of all files and sub-dirs in the directory: [2K[0G  â€¤ MongoFS .getDir(path, expandFiles, callback(err, content)) should retrieve the names of all files and sub-dirs in the directory
    MongoFS .getDir(path, expandFiles, callback(err, content)) should retrieve the values of all files in the directory, if expandFiles is set to true: [2K[0G  â€¤ MongoFS .getDir(path, expandFiles, callback(err, content)) should retrieve the values of all files in the directory, if expandFiles is set to true
    MongoFS .remove(path, timestamp, callback(err)) should remove a file of the given path: [2K[0G  â€¤ MongoFS .remove(path, timestamp, callback(err)) should remove a file of the given path
    MongoFS .remove(path, timestamp, callback(err)) sould remove a file only if the removal timestamp is greater than the latest: [2K[0G  â€¤ MongoFS .remove(path, timestamp, callback(err)) sould remove a file only if the removal timestamp is greater than the latest
    MongoFS .createMapping(path, mapping, callback(err, actions)) should add an entry in the ".m" sub-document of the directory: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) should add an entry in the ".m" sub-document of the directory
    MongoFS .createMapping(path, mapping, callback(err, actions)) should emit actions including the mapping for all files in the directory: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) should emit actions including the mapping for all files in the directory
    MongoFS .createMapping(path, mapping, callback(err, actions)) should emit actions so that when sending the "tramp" actions back, we get mappings for all files in the sub-tree: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) should emit actions so that when sending the "tramp" actions back, we get mappings for all files in the sub-tree
    MongoFS .createMapping(path, mapping, callback(err, actions)) should work whether or not the directory already exists: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) should work whether or not the directory already exists
    MongoFS .createMapping(path, mapping, callback(err, actions)) with .put() should cause subsequent calls to .put() emit the mapping for the new object: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) with .put() should cause subsequent calls to .put() emit the mapping for the new object
    MongoFS .createMapping(path, mapping, callback(err, actions)) with .put() should cause put() that overrides an existing value provide mapping for the new value and unmapping for the old one: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) with .put() should cause put() that overrides an existing value provide mapping for the new value and unmapping for the old one
    MongoFS .createMapping(path, mapping, callback(err, actions)) with .remove() should emit unmapping of the removed content: [2K[0G  â€¤ MongoFS .createMapping(path, mapping, callback(err, actions)) with .remove() should emit unmapping of the removed content
    MongoFS .removeMapping(path, tsid, callback(err, actions)) should remove the mapping with tsid from path, and produce actions to undo its effect: [2K[0G  â€¤ MongoFS .removeMapping(path, tsid, callback(err, actions)) should remove the mapping with tsid from path, and produce actions to undo its effect
    MongoFS as StorageDriver should support any kind of characters in paths, with the exception that slash (/) and star (*): [2K[0G  â€¤ MongoFS as StorageDriver should support any kind of characters in paths, with the exception that slash (/) and star (*)
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) should allow for multiple get and put operations to be performed atomically: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) should allow for multiple get and put operations to be performed atomically
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) should retrieve the value with the highest _ts value: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) should retrieve the value with the highest _ts value
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the value of a file: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the value of a file
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the latest version prior to the transaction timestamp if one is stored: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the latest version prior to the transaction timestamp if one is stored
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the earliest stored version if latest prior to ts is not stored: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should retrieve the earliest stored version if latest prior to ts is not stored
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should not find the file if it was created past the transaction ts, as long as enough versions are stored: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) get should not find the file if it was created past the transaction ts, as long as enough versions are stored
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should write a file so that "get" retrieves it: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should write a file so that "get" retrieves it
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should assign a timestamp to a file if one is not provided: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should assign a timestamp to a file if one is not provided
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should reflect the provided timestamp if one is given: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) put should reflect the provided timestamp if one is given
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should emit actions including the mapping for all files in the directory: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should emit actions including the mapping for all files in the directory
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should emit actions so that when sending the "tramp" actions back, we get mappings for all files in the sub-tree: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should emit actions so that when sending the "tramp" actions back, we get mappings for all files in the sub-tree
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should work whether or not the directory already exists: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map should work whether or not the directory already exists
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with put should cause subsequent puts emit the mapping for the new object: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with put should cause subsequent puts emit the mapping for the new object
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with put should cause puts that overrides an existing value provide mapping for the new value and unmapping for the old one: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with put should cause puts that overrides an existing value provide mapping for the new value and unmapping for the old one
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with remove should emit unmapping of the removed content: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) map with remove should emit unmapping of the removed content
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) unmap should remove the mapping with ts from path, and produce actions to undo its effect: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) unmap should remove the mapping with ts from path, and produce actions to undo its effect
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should remove a file of the given path: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should remove a file of the given path
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should remove a file only if the removal timestamp is greater than the latest: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should remove a file only if the removal timestamp is greater than the latest
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should provide unmapping for them for each mapping that exists: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) remove should provide unmapping for them for each mapping that exists
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getIfExists should emit content actions only for the files that exist in the list: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getIfExists should emit content actions only for the files that exist in the list
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should emit dir actions for all files in the directory: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should emit dir actions for all files in the directory
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should behave properly when used in conjunction with get: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should behave properly when used in conjunction with get
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should emit content entries with file contents when using the expandFiles option: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should emit content entries with file contents when using the expandFiles option
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should not emit files that have been deleted: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) getDir should not emit files that have been deleted
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) tsCond should cause the transaction to be canceled if one of the given files does not have the corresponding ts value: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) tsCond should cause the transaction to be canceled if one of the given files does not have the corresponding ts value
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) tsCond should allow the transaction to happen if the timestamps are accurate: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) tsCond should allow the transaction to happen if the timestamps are accurate
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) accum should create files containing numbers, when given names that do not exist: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) accum should create files containing numbers, when given names that do not exist
    MongoFS as StorageDriver .transaction(trans, callback(err, actions)) accum should add the given number to each file, and emit the previous value: [2K[0G  â€¤ MongoFS as StorageDriver .transaction(trans, callback(err, actions)) accum should add the given number to each file, and emit the previous value
    Dispatcher .transaction(trans, callback(err, actions)) should handle transactions that do not require futher action by forwaring them to storage: [2K[0G  â€¤ Dispatcher .transaction(trans, callback(err, actions)) should handle transactions that do not require futher action by forwaring them to storage
    Dispatcher .transaction(trans, callback(err, actions)) should write actions that require further treatment to the tracker, in a path provided by the scheduler: [2K[0G  â€¤ Dispatcher .transaction(trans, callback(err, actions)) should write actions that require further treatment to the tracker, in a path provided by the scheduler
    Dispatcher .tick(path, callback(err, job)) should select a pending task from the tracker, mark it in progress and emit it in the callback: [2K[0G  â€¤ Dispatcher .tick(path, callback(err, job)) should select a pending task from the tracker, mark it in progress and emit it in the callback
    Dispatcher .tick(path, callback(err, job)) should select a different job on each call: [2K[0G  â€¤ Dispatcher .tick(path, callback(err, job)) should select a different job on each call
    Dispatcher .tick(path, callback(err, job)) should emit undefined as a job if no job is found: [2K[0G  â€¤ Dispatcher .tick(path, callback(err, job)) should emit undefined as a job if no job is found
    Dispatcher .tick(path, callback(err, job)) should take the path from the scheduler if not provided: [2K[0G  â€¤ Dispatcher .tick(path, callback(err, job)) should take the path from the scheduler if not provided
    Dispatcher tock(job, callback(err)) should perform the given job: [2K[0G  â€¤ Dispatcher tock(job, callback(err)) should perform the given job
    Dispatcher .start() and .stop() should cause the dispatcher to automatically take tasks and execute them: [2K[0G  â€¤ Dispatcher .start() and .stop() should cause the dispatcher to automatically take tasks and execute them
  - Dispatcher .wait(ts, callback(err)) should trigger the callback after all work related to this ts has been complete
    Dispatcher mapping should handle map operations with _mapping fields containing HTTP URLs by redirecting them to RESTful mappers: [2K[0G  â€¤ Dispatcher mapping should handle map operations with _mapping fields containing HTTP URLs by redirecting them to RESTful mappers
    MirrorMapper should returns content objects identical to the source, except changing the path: [2K[0G  â€¤ MirrorMapper should returns content objects identical to the source, except changing the path

  73 passing (1 seconds)
  1 pending

